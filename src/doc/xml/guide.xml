<?xml version='1.0'?>
<!DOCTYPE book
  PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
  
<book>

<bookinfo>
<title>ashkelon Guide</title>
<author>Eitan Suez</author>
<date>October 14 2002 (updated May 2003)</date>
</bookinfo>

<chapter>
<title>Overview</title>

<para>
ashkelon is an open source project.  It is a Java API documentation
tool designed for Java developers.  Its goals are the same as the goals
of the well-known javadoc tool that comes with J2SE, whose user interface most
java developers are quite familiar with (see: <ulink url="http://java.sun.com/j2se/javadoc/">http://java.sun.com/j2se/javadoc/</ulink> if you'd like to learn more about javadoc)
</para>

<para>
ashkelon addresses the following issues that javadoc does not:
</para>

<itemizedlist>
<listitem>
  ashkelon is a multi-api documentation system, unlike javadoc which produces single-api documentation
</listitem>
<listitem>
  ashkelon's documentation system leverages <acronym>SQL</acronym> to provide a queriable/searchable repository for documentation
</listitem>
<listitem>
  The <acronym>DHTML</acronym> <acronym>GUI</acronym> produced by ashkelon (which works with Mozilla 1.x or IE 5.x or IE 6.x browsers) is markedly different from the defacto html 3.2 user interface produced by javadoc, which i call "classic."
</listitem>
<listitem>
  ashkelon's user interface is a Java web application, not a set of static html pages
</listitem>
</itemizedlist>

<para>
The javadoc tool is composed of two parts:
</para>

<orderedlist>
<listitem>
  The documentation generator, used to produce html (or other) documentation
</listitem>
<listitem>
  a graphical user interface used to browse and peruse through the documentation (static html pages)
</listitem>
</orderedlist>
  
<para>
Sometimes the same person performs both the generation and referencing the documentation.  however, the more common case is that of an api publisher producing javadocs for the api user who references them.
</para>

<para>
Similarly, ashkelon is also composed of two parts:
</para>

<orderedlist>
<listitem>
  the <emphasis>repository manager</emphasis>, used to populate (and otherwise manage) a database with documentation information
</listitem>
<listitem>
  The <emphasis>viewer application</emphasis>, a web application that provides access to the documentation in a variety of ways (search, browse, cross-reference, etc..).  this app is in some ways markedly different from javadoc's user interface.
</listitem>
</orderedlist>
    
<para>
In an intranet environment, a development team needs to reference a number of APIs from a number of sources, including:
</para>

<orderedlist>
<listitem>
  Internal company code
</listitem>
<listitem>
  Sun APIs (J2SE, J2EE, etc..)
</listitem>
<listitem>
  Popular third party APIs (from Apache, Sourceforge, or other)
</listitem>
</orderedlist>

<para>
A developer may be appointed to the task of administrator.  This individual would be in charge of using the repository manager to populate the ashkelon database with the API documentation.  Alternatively, this person may choose to automate the task entirely and enhance the nightly build process to automatically rebuild the ashkelon repository with the latest docs.
</para>

<para>
The entire development team would use the viewer application as its window into the documentation.  One of the strengths of ashkelon is the various ways in which someone can access information about a Programming Element:
</para>

<itemizedlist>
<listitem>
Hierarchical navigation to a target class or method
</listitem>
<listitem>
Search by name
</listitem>
<listitem>
Search by wildcard
</listitem>
<listitem>
Navigating programmatic relationships
</listitem>
<listitem>
Cross referencing classes or interfaces
</listitem>
<listitem>
Power search feature (search by meta information such as author, modifier (et al) or a combination thereof
</listitem>
</itemizedlist>

<para>
An important difference with ashkelon is that as an administrator,
you will use the repository manager repeatedly to add new APIs
into the repository.  You don't have to (and should not try to)
add all APIs in one step.
</para>

<para>
In an internet environment, it is conceivable that a single high-availability site be made available to the general Java developer community.  Such a site might provide API publishers with online tools to register and populate their APIs in this "global" repository.  The end-result would be publicly-accessible Java API documentation for many APIs which would be constantly kept up-to-date by the various API publishers.
</para>

</chapter>


<chapter>
<title>
Administrator Guide:  Using the Repository Manager
</title>

<para>
At present (ashkelon v0.8.3), the repository manager is a command-line tool whose interface was designed to mirror the interface of the javadoc command line tool (the java documentation generator).  So if you're familiar with the javadoc tool, you have very little to learn to come up to speed with the ashkelon repository manager.
</para>

<note><para>Future plans include the addition of a web-based gui and a swing-based gui</para></note>

<para>
If you are not familiar with using the javadoc command line tool, I recommend that you take a little time to familiarize yourself with it.  Every distribution of J2SE comes with javadoc tool documentation, accessible from the page in:
</para>

<screen>
  $JAVA_HOME/docs/tooldocs/solaris/javadoc.html
    or 
  $JAVA_HOME/docs/tooldocs/win32/javadoc.html
</screen>


<para>
Alternatively this information is available online from the javadoc site at:
</para>
<screen>
  <ulink url="http://java.sun.com/j2se/1.4/docs/tooldocs/windows/javadoc.html">http://java.sun.com/j2se/1.4/docs/tooldocs/windows/javadoc.html</ulink>
 or
  <ulink url="http://java.sun.com/j2se/1.4/docs/tooldocs/solaris/javadoc.html">http://java.sun.com/j2se/1.4/docs/tooldocs/solaris/javadoc.html</ulink>
</screen>


<note>
<para>
Bob Hays has already built an Ant task for ashkelon that can be used to integrate ashkelon with a continuous build process.
</para>
</note>

<para>
The ashkelon command-line tool is called "ashkelon".  It is 
a wrapper shell script for a Java program.  On win32, the file
is "ashkelon.bat" while on unix it's "ashkelon."  These files reside in $ASHK_HOME/bin
</para>

<para>
After installation of ashkelon, you should be able to run ashkelon from the command line:
</para>

<screen>
<prompt>$</prompt> <command>ashkelon</command>
</screen>

<para>
which should produce something similar to this output:
</para>

<screen>
==============================================================
ashkelon Repository Manager (ashkelon v0.8+)

Description:
  Manages a Java Documentation Repository.
  For more information, visit <ulink url="http://www.uptodata.com/">http://www.uptodata.com/</ulink>
  
Usage:
  ashkelon [add [javadoc options] &lt;items&gt; | remove &lt;names&gt; | reset | list]

    add      Add items to repository where items is the names of packages
             and/or source files to be added to the repository
    remove   Remove names from repository.  A name is the fully
             qualified name of a java package, class, or interface
    reset    Reset repository (i.e. delete everything, use with care)
    list     List api names currently existing in the repository

Items Reference
  items = [packagenames] [sourcefiles] [@files]
    packagenames
      A series of package names, separated by spaces, such as:
        java.lang java.lang.reflect java.awt
      You must separately specify each package you want to document.
      Like javadoc, ashkelon uses -sourcepath to look for these package
      names.  Wildcards are not allowed
    sourcefiles
      A series of source file names, separated by spaces, each of which
      can begin with a path and contain a wildcard
    @files
      One or more files that contain packagenames and sourcefiles
      in any order, one name per line
    
Supported javadoc options:
  -overview &lt;file&gt;          Read overview documentation from HTML file
  -public                   Show only public classes and members
  -protected                Show protected/public classes and members (default)
  -package                  Show package/protected/public classes and members
  -private                  Show all classes and members
  -sourcepath &lt;pathlist&gt;    Specify where to find source files
  -classpath &lt;pathlist&gt;     Specify where to find user class files
  -bootclasspath &lt;pathlist&gt; Override location of class files loaded
                            by the bootstrap class loader
  -extdirs &lt;dirlist&gt;        Override location of installed extensions
  -verbose                  Output messages about what Javadoc is doing
  -locale &lt;name&gt;            Locale to be used, e.g. en_US or en_US_WIN
  -encoding &lt;name&gt;          Source file encoding name

Copyright 2001 UptoData, Inc.
==============================================================
</screen>

<para>
You will primarily use the ashkelon tool to add content to your database.  This tool currently supports four main subcommands:
</para>

<variablelist>
 <varlistentry>
  <term><command>ashkelon add</command></term>
  <listitem>use to add APIs to your database</listitem>
 </varlistentry>
 <varlistentry>
  <term><command>ashkelon reset</command></term>
  <listitem>
   use to "nuke" the contents of the database (start from scratch)
  </listitem>
 </varlistentry>
 <varlistentry>
  <term><command>ashkelon list</command></term>
  <listitem>
  lists the APIs currently documented in the database
  </listitem>
 </varlistentry>
 <varlistentry>
  <term><command>ashkelon remove</command></term>
  <listitem>
  opposite of ashkelon add, use it to remove APIs from the repository
  </listitem>
 </varlistentry>
</variablelist>

<para>
<command>ashkelon reset</command> and <command>ashkelon list</command> require no parameters and likewise require no explanation.
</para>

<para>
<command>ashkelon add</command> is richer.  Let's talk about "ashkelon add".
</para>

<sect1>
<title>Documenting Source Code</title>

<para>
Traditionally (i.e. with javadoc) one documents a single API.  So the inputs to the javadoc tool are a list of package names, such as {java.lang, java.io, java.net, ..}
</para>

<para>
  When documenting multiple APIs in a single repository, it's important to also keep track of what api each java package belongs to.  That is, org.apache.tools.ant is part of the ant API whereas org.apache.log4j is part of the log4j API.
</para>
  
<para>
  The ashkelon project has devised a simple xml structure to describe an api.  Here's a sample (more samples are available in the apis/ folder) for the servlet api (file name is servlet.xml):
</para>
  
<example>
<title>Servlet API xml file (descriptor) for ashkelon</title>
<programlisting>
 <![CDATA[
  <?xml version="1.0"?> 
  <api>
  <name>Servlet 2.3 &amp; JSP 1.2</name> 
  <summarydescription>
   JavaTM Servlet technology provides web developers with a simple, consistent 
   mechanism for extending the functionality of a web server and for accessing 
   existing business systems.
  </summarydescription> 
  <description>
   JavaTM Servlet technology provides web developers with a simple, consistent 
   mechanism for extending the functionality of a web server and for accessing 
   existing business systems. A servlet can almost be thought of as an applet 
   that runs on the server side -- without a face. Java servlets have made many 
   web applications possible.
  </description> 
  <publisher>Sun MicroSystems</publisher> 
  <download_url>http://java.sun.com/products/servlet/</download_url> 
  <release_date>2001-08-13T08:00:00.000</release_date> 
  <version>2.3</version>
  <package>javax.servlet</package> 
  <package>javax.servlet.http</package> 
  <package>javax.servlet.jsp</package> 
  <package>javax.servlet.jsp.tagext</package> 
  </api>
  ]]>
</programlisting>
</example>

 <note>
  <para>
    API has a one-to-many relationship with java packages.  That is, an api is usually comprised of one or more java packages.
  </para>
 </note>
 
<para>
  This file is similar to the <filename>package.html</filename> file that you usually have to write for javadoc package documentation.  Except that this file is xml-based and thus more structured, and easier to interpret by a program.
</para>

 <note>
 <para>
 I devised this xml back in 2001 before discovering Maven.  I realize there now exists an overlap between this xml and maven's.  I believe that a formal xml schema should be developed to describe javadocs in general.
 </para>
 </note>
 
<para>
  These xml api "descriptors" are the primary input to the ashkelon script (aside from the actual source code that you're trying to document).  So you'll need to construct them.  The xml file for your API may already exist in the <filename class="directory">apis</filename> folder.  They're really easy to construct otherwise.</para>

<tip><para>
  Almost every API you'll need to populate into ashkelon has
   had javadocs created for it before.  When javadoc is run on a list
   of packages, it leaves a signature in a file called "package-list"
   (check it out, go to <filename class="directory">$JAVA_HOME/docs/api</filename> or <filename class="directory">hibernate/doc/api</filename>
    and you'll see the file).
   Use this list of packages is input to building your api xml file.
</para></tip>

<para>
  So constructing such an xml file is easy:  provide a description,
   url, version number, and other such information.  Most importantly,
   provide the names of the java packages that comprise the API.
   Save the file as <replaceable>apiname</replaceable>.xml (you might also want to consider
    contributing the file back to ashkelon (a list of api.xml files in maintained in the
    ashkelon "apis" folder).
</para>

<para>
  You'll notice a simple perl script (wrap.pl) which will take a package-list and wrap each package name in &lt;package&gt; tags for you.  You'll also notice the Java utility (part of the ashkelon source base) org.ashkelon.util.ApiXml which will construct the xml file for you from the package-list.  All you have to do is fill in the api name, description, and version information.  It's wrapped around a shell script for easy invocation:
</para>

<screen>
<prompt>$</prompt> <command>apixml</command> ~/devel/hibernate/doc/api/package-list > hibernate.xml
</screen>

<para>
  Now you're ready to feed the <replaceable>api</replaceable>.xml to ashkelon:
</para>

<screen>
  <prompt>$</prompt> <command>ashkelon</command> add @<replaceable>apiname</replaceable>.xml
</screen>

<para>
  Real example:
</para>
  
<screen>
  <prompt>$</prompt> <command>ashkelon</command> add @servlet.xml
</screen>

<para>
  ashkelon will take it from here.  It will invoke the javadoc engine
  to parse the source code and produce an object model of the
  information.  ashkelon will proceed to take the information and stuff it
  into its database.  Depending on the speed of your machine and
  the size of the api, the whole process might take 5-10 seconds
  or 2-3 minutes.
</para>

<note><para>
  When populating, you might get a ton of junk warnings from the javadoc engine.  This is normal.  Many people will make typographical mistakes in their doc tags such as <programlisting>@thorws SomeException</programlisting> instead of <programlisting>@throws SomeException</programlisting> which javadoc will warn you about.  If it's your code, you can correct the tag and repeat the add step (actually, make sure to read on about this).
</para></note>
</sect1>

<sect1>
<title>How to update an existing an API</title>

<para>
  Oftentimes you'll want to update an API you've already populated into your database with an updated version.  This can be accomplished in two ways:
</para>

<orderedlist>

  <listitem id="drastic-update">Drastic: nuke everything and start over
    <screen>
     <prompt>$</prompt> <command>ashkelon</command> reset
     <prompt>$</prompt> <command>ashkelon</command> add @<replaceable>api1</replaceable>.xml
     <prompt>$</prompt> <command>ashkelon</command> add @<replaceable>api2</replaceable>.xml
     <prompt>$</prompt> ...
     <prompt>$</prompt> <command>ashkelon</command> add @<replaceable>apin</replaceable>.xml
    </screen>
  </listitem>
     
  <listitem>Differential:  remove the API from the database and repopulate it
    <screen>
     <prompt>$</prompt> <command>ashkelon</command> remove @<replaceable>api</replaceable>.xml
     <prompt>$</prompt> <command>ashkelon</command> add @<replaceable>api</replaceable>.xml
    </screen>
  </listitem>
     
</orderedlist>

<para>
  If your environment uses nightly builds, you'll probably do <link linkend="drastic-update">[1] above</link> nightly.
</para>
</sect1>

<sect1>
<title>J2SE v1.4 Caveats</title>

<para>
  J2SE v1.4 introduces a new keyword "assert" into the java language.  Sun's javadoc tool accomodates this change with the "-source" flag.  In order to get ashkelon to populate APIs that use the assert keyword, you'll need to pass that to the ashkelon script, like so:
</para>

<screen>
  <prompt>$</prompt> <command>ashkelon</command> add -source 1.4 @j2sdk14.xml
</screen>

<tip><para>
  Any flag that javadoc accepts will be passed through to javadoc by ashkelon.  remember, ashkelon uses javadoc under the hood.  ashkelon plugs in to javadoc as a doclet.  ashkelon does not need to explicitly know about the flag (it will pass it through).
</para></tip>

</sect1>


<sect1>
<title>What's This About "sourcepath"?</title>

<para>
  So, when ashkelon runs, it needs to know where to find your source code.  The environment variable <envar>sourcepath</envar> is analogous to <envar>classpath</envar> which we're all familiar with.
</para>

<para>
  It's a colon-delimited (unix) or semicolon-delimited (m$) list of paths where you keep the source code for the APIs you want to document.
</para>
  
<note><para>
  If you don't have source code for what you want to document, you're out of luck.  ashkelon is no different from javadoc in this case.
</para></note>

<tip><para>
  Sun makes available the source code for J2SE, J2ME, and J2EE (and a bunch of other stuff) at:
      <ulink url="http://wwws.sun.com/software/communitysource/">http://wwws.sun.com/software/communitysource/</ulink>
</para></tip>

<para>
  Even though it's not exactly open source, nothing stops you from being able to document and publish sun java APIs within an intranet.  On the other hand, my understanding of Sun's licensing terms is such that you may not publish these javadocs on the internet without express permission.
</para>
</sect1>


<sect1>
<title>Dealing with Very Large APIs (e.g. J2SE)</title>

<para>
  If you look at ashkelon.bat or ashkelon.sh, you'll notice something a little alarming:
</para>

<screen>
    java -Xmx100m
     or
    java -Xmx150m
</screen>

<para>
  This means that when ashkelon runs, it requests 100 or 150 MB of memory to run with.  It probably doesn't need that much memory.  But in some cases (J2SE) it may need even more!
</para>

<para>
  This has nothing to do with ashkelon.  The javadoc tool requires similar amounts of RAM.
</para>

<para>
  But since ashkelon allows you to build a repository in incremental steps, you can actually break up an API into multiple package sets and populate an api in small chunks, thus lowering the memory requirements of the application.
</para>

<para>
  So, here's a trick for populating J2SE in chunks:
</para>

<para>
    I assume you've already created a j2se.xml file (actually there already is one in apis/)
</para>

<para>
    let's say we want to break up J2SE into three sets of packages:  java.*, javax.*, and org.*
</para>

<para>
    You can create java.plist, javax.plist, and org.omg.plist files (the names are immaterial).
    These files are just a list of package names that you want to populate.
</para>

<para>
  You can now do this:
</para>

<screen>
    $ ashkelon add @java.plist
    $ ashkelon add @javax.plist
    $ ashkelon add @org.omg.plist
    $ ashkelon add @j2se.xml
</screen>

<para>
Packages already added so won't be repopulated, only API info (descr, version, etc..) will be added)
</para>
</sect1>

</chapter>


<chapter>
<title>System Architecture</title>

<para>
  Two thorough and complemtentary sources on ashkelon's architecture are:
</para>

<variablelist>
<varlistentry>
<term>July 2003 java.sun.com main story/article</term>
<listitem>
<ulink url="http://java.sun.com/features/2002/07/dbdoc.html">http://java.sun.com/features/2002/07/dbdoc.html</ulink>
</listitem>
</varlistentry>
<varlistentry>
<term>JavaOne (2001) alternate presentation (ppt)</term>
<listitem>
<ulink url="http://www.uptodata.com/1145suez.pdf">http://www.uptodata.com/1145suez.pdf</ulink>
</listitem>
</varlistentry>
</variablelist>

</chapter>

<chapter>
<title>
Database Schema Description
</title>

<para>
 I have created an entity relationship diagram or sorts (pdf) representing the database schema used by ashkelon.  Click on the thumbnail for a full-size png:
 </para>
 
 <para>
<ulink url="figures/ERD.png">
<screenshot>
<screeninfo>ERD</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/ERD-thumb.png" format="PNG" /></imageobject>
<caption>
<para>ERD</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
 </para>

<para>
If you prefer PDF, See <ulink url="figures/ERD.pdf">doc/ERD.pdf</ulink>.
</para>
 
<para>
 The script that constructs the schema for a given database is located in <filename>$ASHK_HOME/db/<replaceable>$dbtype</replaceable>/org/ashkelon/db/ashkelon.sql</filename>
</para>

</chapter>

<chapter>
<title>Viewer Application Screen Shots</title>

<para>
Here are a bunch of screenshots of the DHTML GUI viewer application for ashkelon.  If you haven't yet installed ashkelon, this is what the UI will look like after you've populated a few APIs.  Notice how search results contain programming elements from multiple APIs.
</para>

<table>
<title>ScreenShots of Ashkelon DHTML Client</title>
<tgroup cols="3">
<tbody>
<row>

<entry>
<ulink url="figures/screenshots/apis.png">
<screenshot>
<screeninfo>API Listing</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/apis.png" format="PNG" /></imageobject>
<caption>
<para>API Listing</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/pkglist.png">
<screenshot>
<screeninfo>J2SE Package Listing</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/pkglist.png" format="PNG" /></imageobject>
<caption>
<para>J2SE Package Listing</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/legend.png">
<screenshot>
<screeninfo>Legend</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/legend.png" format="PNG" /></imageobject>
<caption>
<para>Legend:  Color coding and Styles</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>

<row>

<entry>
<ulink url="figures/screenshots/packages.png">
<screenshot>
<screeninfo>Packages View</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/packages.png" format="PNG" /></imageobject>
<caption>
<para>Packages View</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/java-awt-brief.png">
<screenshot>
<screeninfo>java.awt at a glance</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/java-awt-brief.png" format="PNG" /></imageobject>
<caption>
<para>java.awt at a glance</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/java-awt-classes.png">
<screenshot>
<screeninfo>java.awt Class Listing</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/java-awt-classes.png" format="PNG" /></imageobject>
<caption>
<para>java.awt Class Listing</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>

<row>

<entry>
<ulink url="figures/screenshots/java-awt-interfaces.png">
<screenshot>
<screeninfo>java.awt Interfaces Listing</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/java-awt-interfaces.png" format="PNG" /></imageobject>
<caption>
<para>java.awt Interfaces Listing</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/java-awt-main.png">
<screenshot>
<screeninfo>java.awt Main View</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/java-awt-main.png" format="PNG" /></imageobject>
<caption>
<para>java.awt Main View</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/java-awt-tree.png">
<screenshot>
<screeninfo>java.awt Inheritance Hierarchy</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/java-awt-tree.png" format="PNG" /></imageobject>
<caption>
<para>java.awt Inheritance Hierarchy (dynamically collapsible)</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>

<row>

<entry>
<ulink url="figures/screenshots/string-brief.png">
<screenshot>
<screeninfo>String class at a glance</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/string-brief.png" format="PNG" /></imageobject>
<caption>
<para>String class at a glance</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/string-constructor.png">
<screenshot>
<screeninfo>String constructor variants</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/string-constructor.png" format="PNG" /></imageobject>
<caption>
<para>String constructor variants</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/string-main.png">
<screenshot>
<screeninfo>String Class Main View</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/string-main.png" format="PNG" /></imageobject>
<caption>
<para>String Class Main View</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>

<row>

<entry>
<ulink url="figures/screenshots/string-methods-static.png">
<screenshot>
<screeninfo>String Static Methods Listing</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/string-methods-static.png" format="PNG" /></imageobject>
<caption>
<para>String Static Method Listing</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>


<entry>
<ulink url="figures/screenshots/string-methods.png">
<screenshot>
<screeninfo>String Method Listing</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/string-methods.png" format="PNG" /></imageobject>
<caption>
<para>String Method Listing</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/search-method-simple.png">
<screenshot>
<screeninfo>Simple Search</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/search-method-simple.png" format="PNG" /></imageobject>
<caption>
<para>Simple Search</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>

<row>

<entry>
<ulink url="figures/screenshots/search-results-method-simple.png">
<screenshot>
<screeninfo>Simple Search Results</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/search-results-method-simple.png" format="PNG" /></imageobject>
<caption>
<para>Simple Search Results</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/search-power.png">
<screenshot>
<screeninfo>Power Search</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/search-power.png" format="PNG" /></imageobject>
<caption>
<para>Power Search</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/search-results-bloch.png">
<screenshot>
<screeninfo>Power Search Results</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/search-results-bloch.png" format="PNG" /></imageobject>
<caption>
<para>Power Search Results</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>

<row>

<entry>
<ulink url="figures/screenshots/search-wildcard.png">
<screenshot>
<screeninfo>Wildcard Search</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/search-wildcard.png" format="PNG" /></imageobject>
<caption>
<para>Wildcard Search</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/session-find-method.png">
<screenshot>
<screeninfo>Method Detail</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/session-find-method.png" format="PNG" /></imageobject>
<caption>
<para>Method Detail</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/hbm-session-crossref.png">
<screenshot>
<screeninfo>Cross Reference Lookup</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/hbm-session-crossref.png" format="PNG" /></imageobject>
<caption>
<para>Cross Reference Lookup</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>

<row>

<entry>
<ulink url="figures/screenshots/author-sample.png">
<screenshot>
<screeninfo>Author View</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/author-sample.png" format="PNG" /></imageobject>
<caption>
<para>Author View</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>


<entry>
<ulink url="figures/screenshots/stats-authors.png">
<screenshot>
<screeninfo>Author Stats</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/stats-authors.png" format="PNG" /></imageobject>
<caption>
<para>Author Stats</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>


<entry>
<ulink url="figures/screenshots/stats-classcount.png">
<screenshot>
<screeninfo>Package Stats</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/stats-classcount.png" format="PNG" /></imageobject>
<caption>
<para>Package Stats</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>

<row>

<entry>
<ulink url="figures/screenshots/stats-main.png">
<screenshot>
<screeninfo>Stats</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/stats-main.png" format="PNG" /></imageobject>
<caption>
<para>Stats</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>


<entry>
<ulink url="figures/screenshots/settings.png">
<screenshot>
<screeninfo>Settings</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/settings.png" format="PNG" /></imageobject>
<caption>
<para>Settings</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>

</tbody>
</tgroup>
</table> 

</chapter>

<chapter>
<title>
Future Versions and Upcoming Features
</title>

<sect1>
<title>What are the things driving the To-Do list right now</title>

<para>
There are plenty of important tasks to work on that would greatly 
increase the adoption of ashkelon.  Simpler installation, configuration,
tools, adding features, documenting the schema, support for other databases,
integration into tools like eclipse and gforge, more metrics, realizing
the vision of ashkelon serving as a way to measure [and have insight into]
your code in various ways.
</para>

</sect1>

<sect1>
<title>Ashkelon To-Do List</title>

<sect2>
<title>XP</title>

<orderedlist>
<listitem>
Write Unit Tests for Application and begin developing using test-first method.
</listitem>
</orderedlist>

</sect2>

<sect2>
<title>Refactoring</title>

<orderedlist>
<listitem>
 Oracle version uses separate connect-by statements to generate inheritance trees.  Action: revise/refactor to use same solution other databases use
</listitem>
<listitem>
Code that supports multiple GUIs forces data duplication.  Refactor.  Proposed solution:  One set of JSPs generate the content to go on all versions of a page in XML format. Use separate XSLT transform to produce the different look and feel's.
</listitem>
<listitem>
Modularize the build.xml file
</listitem>
<listitem>
Review how application is configured and try to consolidate config files into a single file
</listitem>
<listitem>
Review command line interface for ashkelon manager (populator) for possible improvements
</listitem>
<listitem>
Refactor Model to use EJBs
</listitem>
</orderedlist>

</sect2>

<sect2>
<title>
Enhancements
</title>

<orderedlist>
<listitem>
Support hypersonicsql (idea to to bundle prepopulated database with ashkelon so that basic APIs are already available out of the box without having to populate)
</listitem>
<listitem>
Support for multiple versions of APIs in a single repository. [hays]
</listitem>
</orderedlist>

</sect2>

<sect2>
<title>
Improvements
</title>

<orderedlist>
<listitem>
Replace existing database connection pooling code with 
    a quality implementation that also handles refreshing stale connections.
    Use Jakarta's dbcp. -- update:  apparently dbcp has its own host of
    issues.  not necessarily a win to switch.  existing dbcp code has been
    improved.  pool reset on error.
</listitem>
<listitem>
Smarter parsing of @author tags to extract email address as a separate
     field (revise schema for author table to include email field) [done, though
     might want to revisit method]
</listitem>
<listitem>
A GUI tool for creating api.xml files [note: maven plug-in also assists
     with this, though i haven't tried it firsthand].
</listitem>
</orderedlist>

</sect2>

<sect2>
<title>
UI
</title>

<orderedlist>
<listitem>
Improve usability of GUI and continue refactoring JSPs
  - make ui javabeans aware.  separate accessor/mutator pairs
    as listed properties in the ui.  ones that are read-only
    should display as such (no mutator).  this would really
    clean up the method listing for classes with many methods.
    on the other hand, how does one distinguish between a class
    that coincidentally has getter/setter methods but was never
    intended to be a javabean (example: java.awt.Color)??
    maybe do this only for classes with associated beaninfo classes.

  - scrollable div's in ui should not have hard-coded height.
    is it possible with html to do something layout-manager-like?
    that is, specify that that div should take up whatever
    vertical space remains on the page? : note: consider doing
    this for the xul-based ui.
</listitem>
<listitem>
Port solution to use Struts (Under consideration)
   Current solution is MVC but author's own implementation.
   update:  i don't see a real value to doing this. if
   anything, try tapestry.
</listitem>
<listitem>
GUI Customization:  Make packages page configurable so it
  can list packages of relevance to a specific business 
  environment [hays]
</listitem>
<listitem>
Use JSTL in JSPs [begun]
</listitem>
<listitem>
A third, XUL-based GUI
</listitem>
<listitem>
Make DHTML look &amp; feel work in Safari
</listitem>
</orderedlist>


</sect2>

<sect2>
<title>
Performance
</title>

<orderedlist>
<listitem>
Improve caching implementation
</listitem>
<listitem>
Profile application
</listitem>
</orderedlist>

</sect2>

<sect2>
<title>
Major
</title>

<orderedlist>
<listitem>
GUI for Ashkelon Manager (populator)
  a. Swing
  b. Web front-end
  c. Remote proxy (like cvs pserver et al)
</listitem>
<listitem>
Integration with various IDEs
  a. Eclipse [hays]
  b. NetBeans
  c. JBuilder
  d. IDEA
</listitem>
<listitem>
Integration with GForge
 (Add GForge support to automatically run ashkelon against a project
   and display the documentation as a link under the documentation item) [hays]
</listitem>
<listitem>
Integration with Maven.  That is, make ashkelon a maven-enabled project
   so that code can be built using maven.  Also at some point might want to
   consider writing a maven plugin to the populator (ben walding intends to work
   on an ashkelon plugin for maven)..
</listitem>
</orderedlist>

</sect2>

<sect2>
<title>
Add Value
</title>

<orderedlist>
<listitem>
Integrate with open source measurement tools [hays]
   - jdepend
</listitem>
<listitem>
Add a referenced-by and references list [hays]
</listitem>
</orderedlist>

</sect2>

<sect2>
<title>
XML
</title>

<orderedlist>
<listitem>
add a third dimension (xml) to ashkelon.

   currently model can exist at runtime (org.ashkelon model objects) or in 
   database (have a database schema and code to support transfer of doc 
   info from model to db and back).

   vision:
     cvs export apiname
      exports api information as an xml document

     cvs import apiinfo.xml
      imports an entire api into the db from corresponding info save
       into apiinfo.xml (not to confuse with existing api.xml file
       which contains only info about the api entity; this new xml
       is deep and contains package and class and member info and more)

      new doclet:  ashkelon xml @api.xml
        functions similar to ashkelon add but instead of dumping
        data into db, it would dump it to a target xml file

</listitem>
<listitem>
Build web services on top of this xml infrastructure o allow the transfer of API info to a remote repository
</listitem>
</orderedlist>

</sect2>

<sect2>
<title>
Specific Tasks / Bugs, Small Features
</title>

<orderedlist>
<listitem>
Stats page:  add class count by api in addition to class count
 by package
</listitem>
<listitem>
API Page:  add listing of classes in a single api, flattening
  the various packages an api contains.  sort of like a 
  single package page, but for multiple packages (all
  belonging to a certain api).
</listitem>
<listitem>
Tab selection initialization:  appears to be broken (at least
  on mozilla), fix it
</listitem>
<listitem>
Search:  ability to restrict a search (both 'direct' and 'power')
  to a single API
</listitem>
<listitem>
member or class listing:  modifier columns:  establish min-width in style
   to improve look
</listitem>
<listitem>
Command-line tool:  can sourcepath include jar/zip files?
</listitem>
</orderedlist>
</sect2>

</sect1>

<para>
 Feedback is encouraged.  Write eitan directly at <email>eitan-keyword-tech.cede1b@u2d.com</email> or better yet, write the ashkelon devs mailing list: <email>ashkelon-devs@lists.sourceforge.net</email>
</para>

</chapter>

<chapter>
<title>
Resources
</title>

<para>
For project updates, see:
  <itemizedlist>
  <listitem>
  <ulink url="http://sourceforge.net/projects/ashkelon/">http://sourceforge.net/projects/ashkelon/</ulink>
  </listitem>
  <listitem>
  <ulink url="http://www.uptodata.com/">http://www.uptodata.com/</ulink>
  </listitem>
  </itemizedlist>
</para>

</chapter>


<chapter>
<title>Credits</title>

<para>
Conceived, designed, &amp; built by Eitan Suez, Austin, Texas (www.u2d.com).
</para>
  
<para>
<emphasis>Sincere</emphasis> thanks goes to the following individuals:
</para>

<variablelist>
 <varlistentry>
  <term>
Andreas Schaefer
  </term>
  <listitem>
  For writing the initial ant build file for
  this project, and for being the first individual
  to step up to the plate and actively contribute
  to this project.
  </listitem>
 </varlistentry>

 <varlistentry>
  <term>
  Bob Hays (alephnaught.com)
  </term>
  <listitem>
  For actively helping on the project, contributing
  a number of patches and features, including an ashkelon
  ant task
  </listitem>
 </varlistentry>

 <varlistentry>
  <term>
Ben Walding
  </term>
  <listitem>
  Who wrote a maven plugin for ashkelon
  and who planted the idea in my mind to write a maven
  POM file for ashkelon (forthcoming)
  </listitem>
 </varlistentry>

</variablelist>

</chapter>

<chapter>
<title>Miscellaneous</title>

<sect1>
<title>Project History</title>

<para>
I had the idea that javadocs should be a web application relying on a backend database around 1998.  It took me a couple of years to actually act on this.  On a short vacation trip to hawaii in 2000, I wrote my first stab at a doclet to populate a db.  It worked beautifully.  The results were promising but with only a few days' work invested in this project, there wasn't much to show for:  only a populator doclet.
</para>

<para>
The idea simmered a little longer and a year later I decided that I could no longer sit idle with this idea in my head without doing anything about it.  So I took a 2-week vacation around March 2001 and shut myself in a small hotel room in houston and coded ~ 19 hour days for 14 days straight.  The result was 90% of what ashkelon is today.  This is what I accomplished:
</para>

<itemizedlist>
<listitem>
developed my own MVC framework to support the web application (a la struts)
</listitem>
<listitem>
redesigned and implemented the database schema from scratch
</listitem>
<listitem>
refactored the javadoc html doclet into jsp pages
</listitem>
<listitem>
learned css
</listitem>
<listitem>
wrote an entirely new gui for javadocs, employing dhtml and css vigorously
</listitem>
<listitem>
wrote the viewer application in jsp
</listitem>
<listitem>
wrote my own crappy database connection pool
</listitem>
<listitem>
Added entirely new sections to the viewer app, going beyond the scope of just javadocs (stats section, authors section)
</listitem>
</itemizedlist>

<para>Over the next three years, I added these:
</para>

<itemizedlist>
<listitem>
A second GUI, in the style of javadoc (html 3.2)
</listitem>
<listitem>
postgres and mysql support besides the original oracle version
</listitem>
<listitem>
mozilla support for the DHTML GUI
</listitem>
<listitem>
Added a "power search" feature to complement the simple search feature that had originally been built into the viewer app
</listitem>
</itemizedlist>

<para>
One deduction from this story is that much more can be accomplished in two weeks of immersion compared to three years of trying to squeeze in an hour here or there in the middle of the night.</para>

</sect1>

<sect1>
<title>Origin of Project Name</title>

<para>
The project name "ashkelon" is definitely influenced by names of other open source projects, especially jakarta projects.  There are two main reasons for selecting "ashkelon" as the name for this project.  One is selfish, the other is subtle.
</para>

<para>
The first is my becoming aware of a the jakarta project called "Alexandria" (now defunct).  As I read about Alexandria, I realized that my project had many goals similar to Alexandria's:  making many api docs available on a single site.  One cannot find a more aptly named project, as the city of Alexandria was the host of the largest known library in antiquity.
</para>

<para>It turns out that Ashkelon is also a city, an ancient city, not 250 miles from Alexandria on the mediterranean coast of Israel.  The thought that two projects so close to each other conceptually were also named after two cities close to each other geographically amused me.  Furthermore, the Alexandria project was hosted on what I considered a high profile and high visibilitly open source site:  The Apache Jakarta project.  My project came from relative obscurity (ashkelon likewise is not known for being the source of great libraries or documentation projects).  I thought to myself.. "maybe a great project can emerge from relative obscurity.."
</para>

<para>What tipped the scales in favor of naming the project 'ashkelon' is the additional fact that the city of Ashkelon was my home for a number of years in my youth.
</para>

</sect1>

</chapter>

</book>
