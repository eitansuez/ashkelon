<?xml version='1.0'?>
<!DOCTYPE book
  PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
  
<book>

<bookinfo>
<title>ashkelon</title>
<author>Eitan Suez</author>
<date>October 14 2002 (updated May 2003)</date>
</bookinfo>

<chapter>
<title>Overview</title>

<para>
ashkelon is an open source project.  It is a Java API documentation
tool designed for Java developers.  Its goals are the same as the goals
of the well-known javadoc tool that comes with J2SE, whose user interface most
java developers are quite familiar with (see: <ulink url="http://java.sun.com/j2se/javadoc/">http://java.sun.com/j2se/javadoc/</ulink> if you'd like to learn more about javadoc)
</para>

<para>
ashkelon addresses the following issues that javadoc does not:
</para>

<itemizedlist>
<listitem><para>
  ashkelon is a multi-api documentation system, unlike javadoc which produces single-api documentation</para>
</listitem>
<listitem><para>
  ashkelon's documentation system leverages <acronym>SQL</acronym> to provide a queriable/searchable repository for documentation</para>
</listitem>
<listitem><para>
  The <acronym>DHTML</acronym> <acronym>GUI</acronym> produced by ashkelon (which works with Mozilla 1.x or IE 5.x or IE 6.x browsers) is markedly different from the defacto html 3.2 user interface produced by javadoc, which i call "classic."</para>
</listitem>
<listitem><para>
  ashkelon's user interface is a Java web application, not a set of static html pages</para>
</listitem>
</itemizedlist>

<para>
The javadoc tool is composed of two parts:
</para>

<orderedlist>
<listitem>
  The documentation generator, used to produce html (or other) documentation
</listitem>
<listitem>
  a graphical user interface used to browse and peruse through the documentation (static html pages)
</listitem>
</orderedlist>
  
<para>
Sometimes the same person performs both the generation and referencing the documentation.  however, the more common case is that of an api publisher producing javadocs for the api user who references them.
</para>

<para>
Similarly, ashkelon is also composed of two parts:
</para>

<orderedlist>
<listitem>
  the <emphasis>repository manager</emphasis>, used to populate (and otherwise manage) a database with documentation information
</listitem>
<listitem>
  The <emphasis>viewer application</emphasis>, a web application that provides access to the documentation in a variety of ways (search, browse, cross-reference, etc..).  this app is in some ways markedly different from javadoc's user interface.
</listitem>
</orderedlist>
    
<para>
In an intranet environment, a development team needs to reference a number of APIs from a number of sources, including:
</para>

<orderedlist>
<listitem>
  Internal company code
</listitem>
<listitem>
  Sun APIs (J2SE, J2EE, etc..)
</listitem>
<listitem>
  Popular third party APIs (from Apache, Sourceforge, or other)
</listitem>
</orderedlist>

<para>
A developer may be appointed to the task of administrator.  This individual would be in charge of using the repository manager to populate the ashkelon database with the API documentation.  Alternatively, this person may choose to automate the task entirely and enhance the nightly build process to automatically rebuild the ashkelon repository with the latest docs.
</para>

<para>
The entire development team would use the viewer application as its window into the documentation.  One of the strengths of ashkelon is the various ways in which someone can access information about a Programming Element:
</para>

<itemizedlist>
<listitem>
Hierarchical navigation to a target class or method
</listitem>
<listitem>
Search by name
</listitem>
<listitem>
Search by wildcard
</listitem>
<listitem>
Navigating programmatic relationships
</listitem>
<listitem>
Cross referencing classes or interfaces
</listitem>
<listitem>
Power search feature (search by meta information such as author, modifier (et al) or a combination thereof
</listitem>
</itemizedlist>

<para>
An important difference with ashkelon is that as an administrator,
you will use the repository manager repeatedly to add new APIs
into the repository.  You don't have to (and should not try to)
add all APIs in one step.
</para>

<para>
In an internet environment, it is conceivable that a single high-availability site be made available to the general Java developer community.  Such a site might provide API publishers with online tools to register and populate their APIs in this "global" repository.  The end-result would be publicly-accessible Java API documentation for many APIs which would be constantly kept up-to-date by the various API publishers.
</para>

</chapter>

<chapter>
<title>Download</title>

<para>
Visit the project page on sourceforge at <ulink url="http://sourceforge.net/projects/ashkelon">http://sourceforge.net/projects/ashkelon</ulink>.  On that page, under "Latest File Releases", select the package "ashkelon", a hyperlink which will lead you to the download page.  After you download ashkelon (a tar.gz or tgz file), unpack it.
</para>

</chapter>


<chapter>
<title>Installation</title>

<sect1>
<title>Requirements</title>

<orderedlist>
<listitem>J2SE v1.4.x
</listitem>
<listitem>A servlet &amp; JSP container (I use Jakarta tomcat 5.x at the moment, but have used or received reports from many users and/or vendors that ashkelon works with their servlet container)
</listitem>
<listitem>
postgresql (<ulink url="http://www.postgresql.org/">http://www.postgresql.org/</ulink>) or mysql (<ulink url="http://www.mysql.org">http://www.mysql.org</ulink>)
</listitem>
<listitem>
Jakarta Ant (v1.5 or higher) (<ulink url="http://ant.apache.org">http://ant.apache.org</ulink>)
</listitem>
</orderedlist>

<note><para>In the following subsections, substitute the database type you've decided to use for the replaceable item ${dbtype}</para></note>

</sect1>

<sect1>
<title>Configure database connection and build the distribution</title>

<orderedlist>
<listitem>
Download &amp; unpack the ashkelon tarball
</listitem>
<listitem>
<para>
Edit <filename>db/<replaceable>${dbtype}</replaceable>/org/ashkelon/db/conn-info.properties</filename> to specify the proper database connection information:
</para>

<screen>
      #
      dbtype=mysql
      jdbcDriverName=com.mysql.jdbc.Driver
      connectionURL=jdbc:mysql://localhost/ashkelon
      user=ashkelon
      password=ashkelon

      or
      #
      dbtype=postgres
      jdbcDriverName=org.postgresql.Driver
      connectionURL=jdbc:postgresql://localhost/ashkelon
      user=postgre
      password=
</screen>
</listitem>
<listitem>
<para>Build the code &amp; create jar &amp; make war file:</para>

<example>
<title>For mysql</title>
<screen>
   <prompt>$</prompt> <command>ant</command> -Ddbtype=mysql
</screen>
</example>

<example>
<title>For postgresql</title>
<screen>
   <prompt>$</prompt> <command>ant</command> -Ddbtype=postgres
</screen>
</example>

</listitem>
</orderedlist>

<note><para>I have omitted discussion of the necessary steps to set up a user in mysql or
     postgres for database access;  refer to db documentation for how to do this</para></note>
      
</sect1>

<sect1>
<title>Configure Environment and Prepare Database</title>

<sect2>
<title>Configure environment</title>

<orderedlist>
<listitem>
Make sure you have a <envar>JAVA_HOME</envar> environment variable configured with its value set to the base directory for J2SE (e.g. <filename>c:\j2sdk1.4.2</filename>)
</listitem>
<listitem>
<para>
Set up <envar>ASHK_HOME</envar> environment variable
</para>
<example>
<title>Windows</title>
<screen>
  set ASHK_HOME=c:\ashkelon
</screen>
</example>
<example>
<title>bash</title>
<screen>
  export ASHK_HOME=~/ashkelon
</screen>
</example>
</listitem>
<listitem>
Add <filename class="directory">%ASHK_HOME%\bin</filename> (or <filename class="directory">$ASHK_HOME/bin</filename>) to your path
<screen>
  <prompt>$</prompt> <command>export</command> PATH=$PATH:$ASHK_HOME/bin
</screen>
</listitem>
</orderedlist>
   
</sect2>

<sect2>
<title>Prepare Database</title>

<orderedlist>
<listitem>
In <replaceable>${dbtype}</replaceable>, create database named ashkelon:

<example>
<title>For mysql</title>
<screen><![CDATA[
      c:\> mysql -u username -p
      mysql> create database ashkelon;
      mysql> exit
      ]]>
</screen>
</example>
<example>
<title>For postgresql</title>
<screen>
      ~$ $postgreshome/bin/createdb ashkelon
</screen>
</example>
</listitem>

<listitem>
Run script: <filename>db/<replaceable>${dbtype}</replaceable>/org/ashkelon/db/init.sql</filename>
<example>
<title>Using mysql</title>
<screen>
   c:\ashkelon&gt; mysql -u username -p ashkelon
      &lt; db\mysql\org\ashkelon\db\init.sql
</screen>
</example>

<example>
<title>Using postgresql</title>
<screen>
   ~/ashkelon&gt; psql -d ashkelon
   ashkelon#= \i db/postgres/org/ashkelon/db/init.sql
   ashkelon#= \q
</screen>
</example>
</listitem>
</orderedlist>

</sect2>


<sect2>
<title>Verify that ashkelon repository mgr script works</title>

  <screen>
   <prompt>$</prompt> <command>ashkelon</command>
  </screen>

  <para>   
   should produce a help/usage screen
  </para>

</sect2>

<sect2>
<title>Finish setting up database schema</title>

  <screen>
   <prompt>$</prompt> <command>ashkelon</command> reset
  </screen>

</sect2>

</sect1>

<sect1>
<title>Populate Database</title>

<orderedlist>
<listitem>
<para>
Set up environment variable SOURCEPATH (analogous to classpath,
   it is a list of paths where source code may be located by ashkelon)
   </para>
   
 <example>
 <title>Populating servlet API</title>
 <orderedlist>
 <listitem>
  Download source code for the servlet api from jakarta at: <ulink url="http://jakarta.apache.org/builds/jakarta-servletapi-4/nightly/src">http://jakarta.apache.org/builds/jakarta-servletapi-4/nightly/src</ulink>
  </listitem>
  <listitem>
   Unpack the zip or tar.gz file
  </listitem>
  <listitem>
  <screen>
   set SOURCEPATH=C:\<replaceable>path-to-jakarta-servletapi-4</replaceable>\src\share
    or
   export SOURCEPATH=~/<replaceable>path-to..</replaceable>/src/share
   </screen>
   </listitem>
  </orderedlist>
 </example>
</listitem>

<listitem>
Run ashkelon repository manager to add servlet api to repository:
<screen>
   c:\%ASHK_HOME%\> cd apis
   c:\%ASHK_HOME%\apis\> ashkelon add @servlet.xml
</screen>
</listitem>
<listitem>
<para>
If all succeeds, you should end up with your mysql ashkelon database
   populated with the java api documentation for the servlet api.</para>

   <note><para>You may repeat step 2 for additional APIs as long as they're in your
   sourcepath (follows same convention as classpath: semicolon separator for windows or colon for unix)
   </para></note>
</listitem>
</orderedlist>

</sect1>

<sect1>
<title>Run Ashkelon Web Application</title>

<note><para>JSTL 1.1 libs are now included with ashkelon (no longer need to download it separately)</para></note>

<orderedlist>
<listitem>
sourcepath info also needs to be set in <filename>etc/web.xml</filename> so revise the param-value for the param-name "sourcepath" and rebuild war file:
<screen>
  <prompt>$</prompt> <command>ant</command>
</screen>
</listitem>
<listitem>
Copy war file from <filename>dist/ashkelon.war</filename> to your tomcat  (or other) webapps folder:
<screen>
  <prompt>$</prompt> <command>cp</command> %ASHK_HOME%/dist/ashkelon.war $TOMCAT_HOME/webapps
</screen>
</listitem>
<listitem>
Restart tomcat so it can pick up war file (&amp; unpack it etc..)
</listitem>
<listitem>
Open a web browser (preferably Mozilla but it will work in IE) and hit the URL: <ulink url="http://localhost:8080/ashkelon/">http://localhost:8080/ashkelon/</ulink>  (adjust if you've configured tomcat (or other) to run on another port
</listitem>
</orderedlist>

<note><para>If you add other APIs to the repository, the web app needs to be reloaded
  as it caches content it retrieves from the database.  In tomcat you can use the 
  manager application to do this.</para></note>

</sect1>

</chapter>


<chapter>
<title>
Administrator Guide:  Using the Repository Manager
</title>

<para>
At present (ashkelon v0.8.3), the repository manager is a command-line tool whose interface was designed to mirror the interface of the javadoc command line tool (the java documentation generator).  So if you're familiar with the javadoc tool, you have very little to learn to come up to speed with the ashkelon repository manager.
</para>

<note><para>Future plans include the addition of a web-based gui and a swing-based gui</para></note>

<para>
If you are not familiar with using the javadoc command line tool, I recommend that you take a little time to familiarize yourself with it.  Every distribution of J2SE comes with javadoc tool documentation, accessible from the page in:
</para>

<screen>
  $JAVA_HOME/docs/tooldocs/solaris/javadoc.html
    or 
  $JAVA_HOME/docs/tooldocs/win32/javadoc.html
</screen>


<para>
Alternatively this information is available online from the javadoc site at:
</para>
<screen>
  <ulink url="http://java.sun.com/j2se/1.4/docs/tooldocs/windows/javadoc.html">http://java.sun.com/j2se/1.4/docs/tooldocs/windows/javadoc.html</ulink>
 or
  <ulink url="http://java.sun.com/j2se/1.4/docs/tooldocs/solaris/javadoc.html">http://java.sun.com/j2se/1.4/docs/tooldocs/solaris/javadoc.html</ulink>
</screen>


<note>
<para>
Bob Hays has already built an Ant task for ashkelon that can be used to integrate ashkelon with a continuous build process.
</para>
</note>

<para>
The ashkelon command-line tool is called "ashkelon".  It is 
a wrapper shell script for a Java program.  On win32, the file
is "ashkelon.bat" while on unix it's "ashkelon."  These files reside in $ASHK_HOME/bin
</para>

<para>
After installation of ashkelon, you should be able to run ashkelon from the command line:
</para>

<screen>
<prompt>$</prompt> <command>ashkelon</command>
</screen>

<para>
which should produce something similar to this output:
</para>

<screen>
==============================================================
ashkelon Repository Manager (ashkelon v0.8+)

Description:
  Manages a Java Documentation Repository.
  For more information, visit <ulink url="http://ashkelon.sourceforge.net/">http://ashkelon.sourceforge.net/</ulink>
  
Usage:
  ashkelon [add [javadoc options] &lt;items&gt; | remove &lt;names&gt; | reset | list]

    add      Add items to repository where items is the names of packages
             and/or source files to be added to the repository
    remove   Remove names from repository.  A name is the fully
             qualified name of a java package, class, or interface
    reset    Reset repository (i.e. delete everything, use with care)
    list     List api names currently existing in the repository

Items Reference
  items = [packagenames] [sourcefiles] [@files]
    packagenames
      A series of package names, separated by spaces, such as:
        java.lang java.lang.reflect java.awt
      You must separately specify each package you want to document.
      Like javadoc, ashkelon uses -sourcepath to look for these package
      names.  Wildcards are not allowed
    sourcefiles
      A series of source file names, separated by spaces, each of which
      can begin with a path and contain a wildcard
    @files
      One or more files that contain packagenames and sourcefiles
      in any order, one name per line
    
Supported javadoc options:
  -overview &lt;file&gt;          Read overview documentation from HTML file
  -public                   Show only public classes and members
  -protected                Show protected/public classes and members (default)
  -package                  Show package/protected/public classes and members
  -private                  Show all classes and members
  -sourcepath &lt;pathlist&gt;    Specify where to find source files
  -classpath &lt;pathlist&gt;     Specify where to find user class files
  -bootclasspath &lt;pathlist&gt; Override location of class files loaded
                            by the bootstrap class loader
  -extdirs &lt;dirlist&gt;        Override location of installed extensions
  -verbose                  Output messages about what Javadoc is doing
  -locale &lt;name&gt;            Locale to be used, e.g. en_US or en_US_WIN
  -encoding &lt;name&gt;          Source file encoding name

Copyright 2001 UptoData, Inc.
==============================================================
</screen>

<para>
You will primarily use the ashkelon tool to add content to your database.  This tool currently supports four main subcommands:
</para>

<variablelist>
 <varlistentry>
  <term><command>ashkelon add</command></term>
  <listitem>use to add APIs to your database</listitem>
 </varlistentry>
 <varlistentry>
  <term><command>ashkelon reset</command></term>
  <listitem>
   use to "nuke" the contents of the database (start from scratch)
  </listitem>
 </varlistentry>
 <varlistentry>
  <term><command>ashkelon list</command></term>
  <listitem>
  lists the APIs currently documented in the database
  </listitem>
 </varlistentry>
 <varlistentry>
  <term><command>ashkelon remove</command></term>
  <listitem>
  opposite of ashkelon add, use it to remove APIs from the repository
  </listitem>
 </varlistentry>
</variablelist>

<para>
<command>ashkelon reset</command> and <command>ashkelon list</command> require no parameters and likewise require no explanation.
</para>

<para>
<command>ashkelon add</command> is richer.  Let's talk about "ashkelon add".
</para>

<sect1>
<title>Documenting Source Code</title>

<para>
Traditionally (i.e. with javadoc) one documents a single API.  So the inputs to the javadoc tool are a list of package names, such as {java.lang, java.io, java.net, ..}
</para>

<para>
  When documenting multiple APIs in a single repository, it's important to also keep track of what api each java package belongs to.  That is, org.apache.tools.ant is part of the ant API whereas org.apache.log4j is part of the log4j API.
</para>
  
<para>
  The ashkelon project has devised a simple xml structure to describe an api.  Here's a sample (more samples are available in the apis/ folder) for the servlet api (file name is servlet.xml):
</para>
  
<example>
<title>Servlet API xml file (descriptor) for ashkelon</title>
<programlisting>
 <![CDATA[
  <?xml version="1.0"?> 
  <api>
  <name>Servlet 2.3 &amp; JSP 1.2</name> 
  <summarydescription>
   JavaTM Servlet technology provides web developers with a simple, consistent 
   mechanism for extending the functionality of a web server and for accessing 
   existing business systems.
  </summarydescription> 
  <description>
   JavaTM Servlet technology provides web developers with a simple, consistent 
   mechanism for extending the functionality of a web server and for accessing 
   existing business systems. A servlet can almost be thought of as an applet 
   that runs on the server side -- without a face. Java servlets have made many 
   web applications possible.
  </description> 
  <publisher>Sun MicroSystems</publisher> 
  <download_url>http://java.sun.com/products/servlet/</download_url> 
  <release_date>2001-08-13T08:00:00.000</release_date> 
  <version>2.3</version>
  <package>javax.servlet</package> 
  <package>javax.servlet.http</package> 
  <package>javax.servlet.jsp</package> 
  <package>javax.servlet.jsp.tagext</package> 
  </api>
  ]]>
</programlisting>
</example>

 <note>
  <para>
    API has a one-to-many relationship with java packages.  That is, an api is usually comprised of one or more java packages.
  </para>
 </note>
 
<para>
  This file is similar to the <filename>package.html</filename> file that you usually have to write for javadoc package documentation.  Except that this file is xml-based and thus more structured, and easier to interpret by a program.
</para>

 <note>
 <para>
 I devised this xml back in 2001 before discovering Maven.  I realize there now exists an overlap between this xml and maven's.  I believe that a formal xml schema should be developed to describe javadocs in general.
 </para>
 </note>
 
<para>
  These xml api "descriptors" are the primary input to the ashkelon script (aside from the actual source code that you're trying to document).  So you'll need to construct them.  The xml file for your API may already exist in the <filename class="directory">apis</filename> folder.  They're really easy to construct otherwise.</para>

<tip><para>
  Almost every API you'll need to populate into ashkelon has
   had javadocs created for it before.  When javadoc is run on a list
   of packages, it leaves a signature in a file called "package-list"
   (check it out, go to <filename class="directory">$JAVA_HOME/docs/api</filename> or <filename class="directory">hibernate/doc/api</filename>
    and you'll see the file).
   Use this list of packages is input to building your api xml file.
</para></tip>

<para>
  So constructing such an xml file is easy:  provide a description,
   url, version number, and other such information.  Most importantly,
   provide the names of the java packages that comprise the API.
   Save the file as <replaceable>apiname</replaceable>.xml (you might also want to consider
    contributing the file back to ashkelon (a list of api.xml files in maintained in the
    ashkelon "apis" folder).
</para>

<para>
  ashkelon comes iwth a utility that will produce the necessary API xml file for you from a package-list file.  Notice $ASHK_HOME/bin./apixml which is a wrapper script around org.ashkelon.util.ApiXml:
</para>

<screen>
<prompt>$</prompt> <command>apixml</command> ~/devel/hibernate/doc/api/package-list > hibernate.xml
</screen>

<para>
  After you run the utility, all you have to do is fill in the API name, description, and version information.
</para>

<para>
  Now you're ready to feed the <replaceable>api</replaceable>.xml to ashkelon:
</para>

<screen>
  <prompt>$</prompt> <command>ashkelon</command> add @<replaceable>apiname</replaceable>.xml
</screen>

<example>
<title>Real example</title>  
<screen>
  <prompt>$</prompt> <command>ashkelon</command> add @servlet.xml
</screen>
</example>

<para>
  ashkelon will take it from here.  It will invoke the javadoc engine to parse the source code and produce an object model of the information.  ashkelon will proceed to take the information and stuff it into its database.  Depending on the speed of your machine and the size of the api, the whole process might take 5-10 seconds or 2-3 minutes.
</para>

<note><para>
When populating, you might get a ton of junk warnings from the javadoc engine.  This is normal.  Many people will make typographical mistakes in their doc tags such as <programlisting>@thorws SomeException</programlisting> instead of <programlisting>@throws SomeException</programlisting> which javadoc will warn you about.  If it's your code, you can correct the tag and repeat the add step (actually, make sure to read on about this).
</para></note>
</sect1>

<sect1>
<title>How to update an existing API</title>

<para>
  Oftentimes you'll want to update an API you've already populated into your database with an updated version.  This can be accomplished in two ways:
</para>

<orderedlist>

  <listitem id="drastic-update">Drastic: nuke everything and start over
    <screen>
     <prompt>$</prompt> <command>ashkelon</command> reset
     <prompt>$</prompt> <command>ashkelon</command> add @<replaceable>api1</replaceable>.xml
     <prompt>$</prompt> <command>ashkelon</command> add @<replaceable>api2</replaceable>.xml
     <prompt>$</prompt> ...
     <prompt>$</prompt> <command>ashkelon</command> add @<replaceable>apin</replaceable>.xml
    </screen>
  </listitem>
     
  <listitem>Differential:  remove the API from the database and repopulate it
    <screen>
     <prompt>$</prompt> <command>ashkelon</command> remove @<replaceable>api</replaceable>.xml
     <prompt>$</prompt> <command>ashkelon</command> add @<replaceable>api</replaceable>.xml
    </screen>
  </listitem>
     
</orderedlist>

<para>
  If your environment uses nightly builds, you'll probably do <link linkend="drastic-update">[1] above</link> nightly.
</para>
</sect1>

<sect1>
<title>J2SE v1.4 Caveats</title>

<para>
  J2SE v1.4 introduces a new keyword "assert" into the java language.  Sun's javadoc tool accomodates this change with the "-source" flag.  In order to get ashkelon to populate APIs that use the assert keyword, you'll need to pass that to the ashkelon script, like so:
</para>

<screen>
  <prompt>$</prompt> <command>ashkelon</command> add -source 1.4 @j2sdk14.xml
</screen>

<tip><para>
  Any flag that javadoc accepts will be passed through to javadoc by ashkelon.  remember, ashkelon uses javadoc under the hood.  ashkelon plugs in to javadoc as a doclet.  ashkelon does not need to explicitly know about the flag (it will pass it through).
</para></tip>

</sect1>


<sect1>
<title>What's This About "sourcepath"?</title>

<para>
  So, when ashkelon runs, it needs to know where to find your source code.  The environment variable <envar>sourcepath</envar> is analogous to <envar>classpath</envar> which we're all familiar with.
</para>

<para>
  It's a colon-delimited (unix) or semicolon-delimited (m$) list of paths where you keep the source code for the APIs you want to document.
</para>
  
<note><para>
  If you don't have source code for what you want to document, you're out of luck.  ashkelon is no different from javadoc in this case.
</para></note>

<tip><para>
  Sun makes available the source code for J2SE, J2ME, and J2EE (and a bunch of other stuff) at:
      <ulink url="http://wwws.sun.com/software/communitysource/">http://wwws.sun.com/software/communitysource/</ulink>
</para></tip>

<para>
  Even though it's not exactly open source, nothing stops you from being able to document and publish sun java APIs within an intranet.  On the other hand, my understanding of Sun's licensing terms is such that you may not publish these javadocs on the internet without express permission.
</para>
</sect1>


<sect1>
<title>Dealing with Very Large APIs (e.g. J2SE)</title>

<para>
  If you look at ashkelon.bat or ashkelon.sh, you'll notice something a little alarming:
</para>

<screen>
    java -Xmx100m
     or
    java -Xmx150m
</screen>

<para>
  This means that when ashkelon runs, it requests 100 or 150 MB of memory to run with.  It probably doesn't need that much memory.  But in some cases (J2SE) it may need even more!
</para>

<para>
  This has nothing to do with ashkelon.  The javadoc tool requires similar amounts of RAM.
</para>

<para>
  But since ashkelon allows you to build a repository in incremental steps, you can actually break up an API into multiple package sets and populate an api in small chunks, thus lowering the memory requirements of the application.
</para>

<para>
  So, here's a trick for populating J2SE in chunks:
</para>

<para>
    I assume you've already created a j2se.xml file (actually there already is one in apis/)
</para>

<para>
    let's say we want to break up J2SE into three sets of packages:  java.*, javax.*, and org.*
</para>

<para>
    You can create java.plist, javax.plist, and org.omg.plist files (the names are immaterial).
    These files are just a list of package names that you want to populate.
</para>

<para>
  You can now do this:
</para>

<screen>
    $ ashkelon add @java.plist
    $ ashkelon add @javax.plist
    $ ashkelon add @org.omg.plist
    $ ashkelon add @j2se.xml
</screen>

<para>
Packages already added so won't be repopulated, only API info (descr, version, etc..) will be added)
</para>
</sect1>

</chapter>


<chapter>
<title>System Architecture</title>

<para>
  Two thorough and complemtentary sources on ashkelon's architecture are:
</para>

<variablelist>
<varlistentry>
<term>July 2002 java.sun.com main story/article</term>
<listitem>
<ulink url="http://java.sun.com/features/2002/07/dbdoc.html">http://java.sun.com/features/2002/07/dbdoc.html</ulink>
</listitem>
</varlistentry>
<varlistentry>
<term>JavaOne (2002) alternate presentation (ppt)</term>
<listitem>
<ulink url="http://www.u2d.com/1145suez.pdf">http://www.u2d.com/1145suez.pdf</ulink>
</listitem>
</varlistentry>
</variablelist>

</chapter>

<chapter>
<title>
Database Schema Description
</title>

<para>
 I have created an entity relationship diagram or sorts (pdf) representing the database schema used by ashkelon.  Click on the thumbnail for a full-size png:
 </para>
 
 <para>
<ulink url="figures/ERD.png">
<screenshot>
<screeninfo>ERD</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/ERD-thumb.png" format="PNG" /></imageobject>
<caption>
<para>ERD</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
 </para>

<para>
If you prefer PDF, See <ulink url="figures/ERD.pdf">doc/ERD.pdf</ulink>.
</para>
 
<para>
 The script that constructs the schema for a given database is located in <filename>$ASHK_HOME/db/<replaceable>$dbtype</replaceable>/org/ashkelon/db/ashkelon.sql</filename>
</para>

</chapter>

<chapter>
<title>Viewer Application Screen Shots</title>

<para>
Here are a bunch of screenshots of the DHTML GUI viewer application for ashkelon.  If you haven't yet installed ashkelon, this is what the UI will look like after you've populated a few APIs.  Notice how search results contain programming elements from multiple APIs.
</para>

<table>
<title>APIs and Package Listings</title>
<tgroup cols="3">
<tbody>
<row>

<entry>
<ulink url="figures/screenshots/apis.png">
<screenshot>
<screeninfo>API Listing</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/apis.png" format="PNG" /></imageobject>
<caption>
<para>API Listing</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/pkglist.png">
<screenshot>
<screeninfo>J2SE Package Listing</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/pkglist.png" format="PNG" /></imageobject>
<caption>
<para>J2SE Package Listing</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/packages.png">
<screenshot>
<screeninfo>Packages View</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/packages.png" format="PNG" /></imageobject>
<caption>
<para>Packages View</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>
</tbody>
</tgroup>
</table>

<table>
<title>Sample Package: java.awt</title>
<tgroup cols="3">
<tbody>
<row>

<entry>
<ulink url="figures/screenshots/java-awt-brief.png">
<screenshot>
<screeninfo>java.awt at a glance</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/java-awt-brief.png" format="PNG" /></imageobject>
<caption>
<para>java.awt at a glance</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/java-awt-classes.png">
<screenshot>
<screeninfo>java.awt Class Listing</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/java-awt-classes.png" format="PNG" /></imageobject>
<caption>
<para>java.awt Class Listing</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/java-awt-interfaces.png">
<screenshot>
<screeninfo>java.awt Interfaces Listing</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/java-awt-interfaces.png" format="PNG" /></imageobject>
<caption>
<para>java.awt Interfaces Listing</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>

<row>

<entry>
<ulink url="figures/screenshots/java-awt-main.png">
<screenshot>
<screeninfo>java.awt Main View</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/java-awt-main.png" format="PNG" /></imageobject>
<caption>
<para>java.awt Main View</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/java-awt-tree.png">
<screenshot>
<screeninfo>java.awt Inheritance Hierarchy</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/java-awt-tree.png" format="PNG" /></imageobject>
<caption>
<para>java.awt Inheritance Hierarchy (dynamically collapsible)</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>
</tbody>
</tgroup>
</table>


<table>
<title>Sample Class: java.lang.String</title>
<tgroup cols="3">
<tbody>
<row>

<entry>
<ulink url="figures/screenshots/string-brief.png">
<screenshot>
<screeninfo>String class at a glance</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/string-brief.png" format="PNG" /></imageobject>
<caption>
<para>String class at a glance</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/string-constructor.png">
<screenshot>
<screeninfo>String constructor variants</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/string-constructor.png" format="PNG" /></imageobject>
<caption>
<para>String constructor variants</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/string-main.png">
<screenshot>
<screeninfo>String Class Main View</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/string-main.png" format="PNG" /></imageobject>
<caption>
<para>String Class Main View</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>

<row>

<entry>
<ulink url="figures/screenshots/string-methods.png">
<screenshot>
<screeninfo>String Method Listing</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/string-methods.png" format="PNG" /></imageobject>
<caption>
<para>String Method Listing</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/string-methods-static.png">
<screenshot>
<screeninfo>String Static Methods Listing</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/string-methods-static.png" format="PNG" /></imageobject>
<caption>
<para>String Static Method Listing</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>
</tbody>
</tgroup>
</table>


<table>
<title>Search</title>
<tgroup cols="3">
<tbody>
<row>

<entry>
<ulink url="figures/screenshots/search-method-simple.png">
<screenshot>
<screeninfo>Simple Search</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/search-method-simple.png" format="PNG" /></imageobject>
<caption>
<para>Simple Search</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/search-results-method-simple.png">
<screenshot>
<screeninfo>Simple Search Results</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/search-results-method-simple.png" format="PNG" /></imageobject>
<caption>
<para>Simple Search Results</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/search-power.png">
<screenshot>
<screeninfo>Power Search</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/search-power.png" format="PNG" /></imageobject>
<caption>
<para>Power Search</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>

<row>

<entry>
<ulink url="figures/screenshots/search-results-bloch.png">
<screenshot>
<screeninfo>Power Search Results</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/search-results-bloch.png" format="PNG" /></imageobject>
<caption>
<para>Power Search Results</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/search-wildcard.png">
<screenshot>
<screeninfo>Wildcard Search</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/search-wildcard.png" format="PNG" /></imageobject>
<caption>
<para>Wildcard Search</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>
</tbody>
</tgroup>
</table>

<table>
<title>Method Detail &amp; Cross Reference Lookup</title>
<tgroup cols="3">
<tbody>
<row>

<entry>
<ulink url="figures/screenshots/session-find-method.png">
<screenshot>
<screeninfo>Method Detail</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/session-find-method.png" format="PNG" /></imageobject>
<caption>
<para>Method Detail</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/hbm-session-crossref.png">
<screenshot>
<screeninfo>Cross Reference Lookup</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/hbm-session-crossref.png" format="PNG" /></imageobject>
<caption>
<para>Cross Reference Lookup</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>
</tbody>
</tgroup>
</table>

<table>
<title>Stats</title>
<tgroup cols="3">
<tbody>
<row>

<entry>
<ulink url="figures/screenshots/stats-authors.png">
<screenshot>
<screeninfo>Author Stats</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/stats-authors.png" format="PNG" /></imageobject>
<caption>
<para>Author Stats</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>


<entry>
<ulink url="figures/screenshots/stats-classcount.png">
<screenshot>
<screeninfo>Package Stats</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/stats-classcount.png" format="PNG" /></imageobject>
<caption>
<para>Package Stats</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/stats-main.png">
<screenshot>
<screeninfo>Stats</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/stats-main.png" format="PNG" /></imageobject>
<caption>
<para>Stats</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

</row>
</tbody>
</tgroup>
</table>

<table>
<title>Miscellaneous</title>
<tgroup cols="3">
<tbody>
<row>

<entry>
<ulink url="figures/screenshots/author-sample.png">
<screenshot>
<screeninfo>Author View</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/author-sample.png" format="PNG" /></imageobject>
<caption>
<para>Author View</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>


<entry>
<ulink url="figures/screenshots/settings.png">
<screenshot>
<screeninfo>Settings</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/settings.png" format="PNG" /></imageobject>
<caption>
<para>Settings</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>

<entry>
<ulink url="figures/screenshots/legend.png">
<screenshot>
<screeninfo>Legend</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/screenshots/thumbs/legend.png" format="PNG" /></imageobject>
<caption>
<para>Legend:  Color coding and Styles</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
</entry>


</row>

</tbody>
</tgroup>
</table> 

</chapter>

<chapter>
<title>
Future Versions and Upcoming Features
</title>

<sect1>
<title>What are the things driving the To-Do list right now</title>

<para>
Here are what I believe to be important enhancements to ashkelon:

<itemizedlist>
<listitem>Brainless installation</listitem>
<listitem>A public repository and web site with support for API owners and maintainers, remote population</listitem>
<listitem>Eclipse plugin</listitem>
<listitem>More stats, code metrics</listitem>
<listitem>javadocs xml representation and xml marshalling</listitem>
<listitem>a XUL gui</listitem>
<listitem>GUIs for the repository manager</listitem>
</itemizedlist>

</para>

</sect1>

<sect1>
<title>Ashkelon Task List</title>


<sect2>
<title>xml</title>

<orderedlist>
<listitem>
Add a third dimension (xml) to ashkelon.
<para>
   Currently model can exist at runtime (org.ashkelon model objects) or in 
   database (have a database schema and code to support transfer of doc 
   info from model to db and back).
</para>

<para>Here's what I envision:</para>
<variablelist>
<varlistentry>
<term>
 <command>ashkelon</command> export <replaceable>apiname</replaceable>
</term>
<listitem>(Database to XML)
Exports API information as an xml document
</listitem>
</varlistentry>

<varlistentry>
<term>
 <command>ashkelon</command> import <replaceable>apiinfo.xml</replaceable>
</term>
<listitem>(XML to Database)
Imports an entire API into the db from corresponding info saved in apiinfo.xml (not to confuse with existing api.xml file which contains only info about the api entity; this new xml is deep and contains package and class and member info and more)
</listitem>
</varlistentry>

<varlistentry>
<term>
 New doclet: <command>ashkelon</command> xml <replaceable>@api.xml</replaceable>
</term>
<listitem>(Source code to XML)
Functions similar to <command>ashkelon add</command> but instead of dumping data into db, it would dump it to a target xml file
</listitem>
</varlistentry>

</variablelist> 

 <para>
 Here's a crude diagram of what I envision..
<ulink url="figures/vision.png">
<screenshot>
<screeninfo>Unified marshalling vision</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="figures/vision-thumb.png" format="PNG" /></imageobject>
<caption>
<para>Unified marshalling vision</para>
</caption>
</mediaobject>
</screenshot>
</ulink>
 </para>


</listitem>
<listitem>
Build web services on top of this xml infrastructure to allow the transfer of API info to a remote repository
</listitem>
</orderedlist>

</sect2>


<sect2>
<title>Refactoring/Enhancements</title>

<orderedlist>
<listitem>
Code that supports multiple GUIs forces data duplication.  Refactor.  Proposed solution:  One set of JSPs generate the content to go on all versions of a page in XML format. Use separate XSLT transform to produce the different look and feel's.
</listitem>
<listitem>
Review how application is configured and try to consolidate config files into a single file (look at Spring?)
</listitem>

<listitem>
Support hypersonicsql (idea is to bundle prepopulated database with ashkelon so that basic APIs are already available out of the box without having to populate)
</listitem>
<listitem>
Improve caching implementation
</listitem>

</orderedlist>

</sect2>

<sect2>
<title>
UI
</title>

<orderedlist>
<listitem>
Improve usability of GUI and continue refactoring JSPs
<orderedlist>
<listitem>
  Make ui javabeans aware.  separate accessor/mutator pairs
    as listed properties in the ui.  ones that are read-only
    should display as such (no mutator).  this would really
    clean up the method listing for classes with many methods.
    on the other hand, how does one distinguish between a class
    that coincidentally has getter/setter methods but was never
    intended to be a javabean (example: java.awt.Color)??
    maybe do this only for classes with associated beaninfo classes.
</listitem>
<listitem>
  Scrollable div's in ui should not have hard-coded height.
    is it possible with html to do something layout-manager-like?
    that is, specify that that div should take up whatever
    vertical space remains on the page? : note: consider doing
    this for the xul-based ui.
</listitem>
</orderedlist>

</listitem>

<listitem>
A third, XUL-based GUI
</listitem>

<listitem>
GUI for Ashkelon Manager (populator)
  <orderedlist>
  <listitem>
  Swing
  </listitem>
  <listitem>
  Web front-end
  </listitem>
  <listitem>
  Remote proxy (like cvs pserver et al)
  </listitem>
  </orderedlist>
  
</listitem>
<listitem>
Eclipse plugin
</listitem>

</orderedlist>

</sect2>

<sect2>
<title>
Specific Tasks / Bugs, Small Features
</title>

<orderedlist>
<listitem>
Stats page:  add class count by api in addition to class count
 by package
</listitem>
<listitem>
API Page:  add listing of classes in a single api, flattening
  the various packages an api contains.  sort of like a 
  single package page, but for multiple packages (all
  belonging to a certain api).
</listitem>
<listitem>
Tab selection initialization:  appears to be broken (at least on mozilla); fix it
</listitem>
<listitem>
Search:  ability to restrict a search (both 'direct' and 'power') to a single API
</listitem>
<listitem>
Member or class listing:  modifier columns:  establish min-width in style to improve look
</listitem>
<listitem>
Command-line tool:  can sourcepath include jar/zip files?
</listitem>
</orderedlist>
</sect2>

</sect1>

<para>
 Feedback is encouraged.  Write eitan directly at <email>eitan-keyword-tech.cede1b@u2d.com</email> or better yet, write the ashkelon devs mailing list: <email>ashkelon-devs@lists.sourceforge.net</email>
</para>

</chapter>

<chapter>
<title>
Resources
</title>

<para>
For project updates, see:
  <itemizedlist>
  <listitem>
  <ulink url="http://sourceforge.net/projects/ashkelon/">http://sourceforge.net/projects/ashkelon/</ulink>
  </listitem>
  <listitem>
  <ulink url="http://ashkelon.sourceforge.net/">http://ashkelon.sourceforge.net/</ulink>
  </listitem>
  </itemizedlist>
</para>

</chapter>


<chapter>
<title>Credits</title>

<para>
Conceived, designed, &amp; built by Eitan Suez, Austin, Texas (www.u2d.com).
</para>
  
<para>
<emphasis>Sincere</emphasis> thanks goes to the following individuals:
</para>

<variablelist>
 <varlistentry>
  <term>
Andreas Schaefer
  </term>
  <listitem>
  For writing the initial ant build file for
  this project, and for being the first individual
  to step up to the plate and actively contribute
  to this project.
  </listitem>
 </varlistentry>

 <varlistentry>
  <term>
  Bob Hays (alephnaught.com)
  </term>
  <listitem>
  For actively helping on the project, contributing
  a number of patches and features, including an ashkelon
  ant task
  </listitem>
 </varlistentry>

 <varlistentry>
  <term>
Ben Walding
  </term>
  <listitem>
  Who wrote a maven plugin for ashkelon
  and who planted the idea in my mind to write a maven
  POM file for ashkelon (forthcoming)
  </listitem>
 </varlistentry>

</variablelist>

</chapter>

<chapter>
<title>Miscellaneous</title>

<sect1>
<title>Project History</title>

<para>
I had the idea that javadocs should be a web application relying on a backend database around 1998.  It took me a couple of years to actually act on this.  On a short vacation trip to hawaii in 2000, I wrote my first stab at a doclet to populate a db.  It worked beautifully.  The results were promising but with only a few days' work invested in this project, there wasn't much to show for:  only a populator doclet.
</para>

<para>
The idea simmered a little longer and a year later I decided that I could no longer sit idle with this idea in my head without doing anything about it.  So I took a 2-week vacation around March 2001 and shut myself in a small hotel room in houston and coded ~ 19 hour days for 14 days straight.  The result was 90% of what ashkelon is today.  This is what I accomplished:
</para>

<itemizedlist>
<listitem>
developed my own MVC framework to support the web application (a la struts)
</listitem>
<listitem>
redesigned and implemented the database schema from scratch
</listitem>
<listitem>
refactored the javadoc html doclet into jsp pages
</listitem>
<listitem>
learned css
</listitem>
<listitem>
wrote an entirely new gui for javadocs, employing dhtml and css vigorously
</listitem>
<listitem>
wrote the viewer application in jsp
</listitem>
<listitem>
wrote my own crappy database connection pool
</listitem>
<listitem>
Added entirely new sections to the viewer app, going beyond the scope of just javadocs (stats section, authors section)
</listitem>
</itemizedlist>

<para>Over the next three years, I added these:
</para>

<itemizedlist>
<listitem>
A second GUI, in the style of javadoc (html 3.2)
</listitem>
<listitem>
postgres and mysql support besides the original oracle version
</listitem>
<listitem>
mozilla support for the DHTML GUI
</listitem>
<listitem>
Added a "power search" feature to complement the simple search feature that had originally been built into the viewer app
</listitem>
</itemizedlist>

<para>
One deduction from this story is that much more can be accomplished in two weeks of immersion compared to three years of trying to squeeze in an hour here or there in the middle of the night.</para>

</sect1>

<sect1>
<title>Origin of Project Name</title>

<para>
The project name "ashkelon" is definitely influenced by names of other open source projects, especially jakarta projects.  There are two main reasons for selecting "ashkelon" as the name for this project.  One is selfish, the other is subtle.
</para>

<para>
I became aware of a Jakarta project called "Alexandria" (now defunct).  As I read about Alexandria, I realized that my project had many goals similar to Alexandria's:  making many api docs available in a single place.  One cannot find a more aptly named project, as the city of Alexandria was the host of the largest known library in antiquity.
</para>

<para>It turns out that Ashkelon is also a city, an ancient city, not 250 miles from Alexandria on the mediterranean coast of Israel.  The thought that two projects so close to each other conceptually were also named after two cities close to each other geographically amused me.  Furthermore, the Alexandria project was hosted on what I considered to be a high profile and high visibilitly open source site:  The Apache Jakarta project.  My project came from relative obscurity (ashkelon likewise is not known for being the source of great libraries or documentation projects).  I thought to myself.. "maybe a great project can emerge from relative obscurity.."
</para>

<para>What tipped the scales in favor of naming the project 'ashkelon' is the additional fact that the city of Ashkelon was my home for a number of years in my youth.
</para>

</sect1>

</chapter>

</book>
